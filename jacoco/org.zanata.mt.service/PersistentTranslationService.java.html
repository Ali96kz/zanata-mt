<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PersistentTranslationService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mt-server</a> &gt; <a href="index.source.html" class="el_package">org.zanata.mt.service</a> &gt; <span class="el_source">PersistentTranslationService.java</span></div><h1>PersistentTranslationService.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2017, Red Hat, Inc. and individual contributors
 * as indicated by the @author tags. See the copyright.txt file in the
 * distribution for a full listing of individual contributors.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 */
package org.zanata.mt.service;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

import javax.ejb.Stateless;
import javax.ejb.TransactionAttribute;
import javax.enterprise.inject.Instance;
import javax.inject.Inject;
import javax.validation.constraints.NotNull;
import javax.ws.rs.BadRequestException;
import javax.ws.rs.core.MediaType;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.zanata.mt.backend.BackendLocaleCode;
import org.zanata.mt.dao.TextFlowDAO;
import org.zanata.mt.dao.TextFlowTargetDAO;
import org.zanata.mt.exception.ZanataMTException;
import org.zanata.mt.model.AugmentedTranslation;
import org.zanata.mt.model.BackendID;
import org.zanata.mt.model.Document;
import org.zanata.mt.model.Locale;
import org.zanata.mt.model.TextFlow;
import org.zanata.mt.model.TextFlowTarget;
import org.zanata.mt.util.HashUtil;
import org.zanata.mt.util.ShortString;

import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.common.collect.Multimap;

/**
 * @author Alex Eng &lt;a href=&quot;mailto:aeng@redhat.com&quot;&gt;aeng@redhat.com&lt;/a&gt;
 * @author Patrick Huang &lt;a href=&quot;mailto:pahuang@redhat.com&quot;&gt;pahuang@redhat.com&lt;/a&gt;
 */
@Stateless
public class PersistentTranslationService {
<span class="fc" id="L65">    private static final Logger LOG =</span>
<span class="fc" id="L66">        LoggerFactory.getLogger(PersistentTranslationService.class);</span>

    private TextFlowDAO textFlowDAO;

    private TextFlowTargetDAO textFlowTargetDAO;

    private Map&lt;BackendID, TranslatorBackend&gt; translatorBackendMap;

    @SuppressWarnings(&quot;unused&quot;)
<span class="fc" id="L75">    public PersistentTranslationService() {</span>
<span class="fc" id="L76">    }</span>

    @Inject
    public PersistentTranslationService(TextFlowDAO textFlowDAO,
            TextFlowTargetDAO textFlowTargetDAO,
<span class="fc" id="L81">            Instance&lt;TranslatorBackend&gt; translatorBackends) {</span>
<span class="fc" id="L82">        this.textFlowDAO = textFlowDAO;</span>
<span class="fc" id="L83">        this.textFlowTargetDAO = textFlowTargetDAO;</span>

<span class="fc" id="L85">        Map&lt;BackendID, TranslatorBackend&gt; backendMap = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L86" title="All 2 branches covered.">        for (TranslatorBackend backend : translatorBackends) {</span>
<span class="fc" id="L87">            backendMap.put(backend.getId(), backend);</span>
<span class="fc" id="L88">        }</span>

<span class="fc" id="L90">        translatorBackendMap = Collections.unmodifiableMap(backendMap);</span>
<span class="fc" id="L91">    }</span>

    /**
     * Translate multiple string in an api trigger
     *
     * Get from database if exists (hash) from same document,
     * if not exist, get latest TF from DB with matching hash,
     * else from MT engine
     */
    @TransactionAttribute
    public List&lt;String&gt; translate(@NotNull Document document,
            @NotNull List&lt;String&gt; sourceStrings,
            @NotNull Locale fromLocale, @NotNull Locale toLocale,
            @NotNull BackendID backendID, @NotNull MediaType mediaType,
            Optional&lt;String&gt; category)
            throws BadRequestException, ZanataMTException {
<span class="pc bpc" id="L107" title="2 of 10 branches missed.">        if (sourceStrings == null || sourceStrings.isEmpty() || fromLocale == null</span>
                || toLocale == null || backendID == null) {
<span class="fc" id="L109">            throw new BadRequestException();</span>
        }

        // get translator backend for MT engine by requested backend id
<span class="fc" id="L113">        TranslatorBackend translatorBackend = getTranslatorBackend(backendID);</span>

<span class="fc" id="L115">        BackendLocaleCode mappedFromLocaleCode =</span>
<span class="fc" id="L116">                translatorBackend.getMappedLocale(fromLocale.getLocaleCode());</span>
<span class="fc" id="L117">        BackendLocaleCode mappedToLocaleCode =</span>
<span class="fc" id="L118">                translatorBackend.getMappedLocale(toLocale.getLocaleCode());</span>

<span class="fc" id="L120">        List&lt;String&gt; results = new ArrayList&lt;&gt;(sourceStrings);</span>
<span class="fc" id="L121">        Multimap&lt;String, Integer&gt; untranslatedIndexMap = ArrayListMultimap.create();</span>

<span class="fc" id="L123">        Map&lt;Integer, TextFlow&gt; indexTextFlowMap = Maps.newHashMap();</span>

        // search from database
<span class="fc bfc" id="L126" title="All 2 branches covered.">        for (int sourceStringIndex = 0; sourceStringIndex &lt; sourceStrings.size(); sourceStringIndex++) {</span>
<span class="fc" id="L127">            String string = sourceStrings.get(sourceStringIndex);</span>
<span class="fc" id="L128">            String contentHash = HashUtil.generateHash(string);</span>
<span class="fc" id="L129">            Optional&lt;TextFlow&gt; matchedHashTf =</span>
<span class="fc" id="L130">                    tryFindTextFlowByContentHashFromDB(document, fromLocale, toLocale,</span>
                            backendID, contentHash);

<span class="fc bfc" id="L133" title="All 2 branches covered.">            if (matchedHashTf.isPresent()) {</span>
                // we found a matching text flow in database
                // now check to see if it has translation from the same provider
<span class="fc" id="L136">                TextFlow matchedTf = matchedHashTf.get();</span>
<span class="fc" id="L137">                Optional&lt;TextFlowTarget&gt; matchedTarget = findTargetByLocaleAndProvider(</span>
                        toLocale, backendID, matchedTf);

<span class="fc bfc" id="L140" title="All 2 branches covered.">                if (matchedTarget.isPresent()) {</span>
<span class="fc" id="L141">                    TextFlowTarget matchedEntity = matchedTarget.get();</span>
<span class="pc bpc" id="L142" title="1 of 2 branches missed.">                    if (LOG.isInfoEnabled()) {</span>
<span class="fc" id="L143">                        LOG.info(</span>
                                &quot;Found match, Source {}:{}:{}\nTranslation {}:{}&quot;,
<span class="fc" id="L145">                                fromLocale.getLocaleCode(), document.getUrl(),</span>
<span class="fc" id="L146">                                ShortString.shorten(string),</span>
<span class="fc" id="L147">                                toLocale.getLocaleCode(),</span>
<span class="fc" id="L148">                                ShortString.shorten(matchedEntity.getContent()));</span>
                    }

<span class="fc" id="L151">                    results.set(sourceStringIndex, matchedEntity.getContent());</span>
<span class="fc" id="L152">                } else {</span>
<span class="fc" id="L153">                    untranslatedIndexMap.put(string, sourceStringIndex);</span>
<span class="fc" id="L154">                    indexTextFlowMap.put(sourceStringIndex, matchedTf);</span>
                }
<span class="fc" id="L156">            } else {</span>
<span class="fc" id="L157">                untranslatedIndexMap.put(string, sourceStringIndex);</span>
            }
        }

        // see if we got all translations from database records
<span class="fc bfc" id="L162" title="All 2 branches covered.">        if (untranslatedIndexMap.isEmpty()) {</span>
<span class="fc" id="L163">            return results;</span>
        }

        // translate using requested MT engine
<span class="fc" id="L167">        List&lt;String&gt; sourcesToTranslate = Lists.newArrayList(untranslatedIndexMap.keySet());</span>
<span class="fc" id="L168">        List&lt;AugmentedTranslation&gt; translations =</span>
<span class="fc" id="L169">                translatorBackend.translate(sourcesToTranslate, mappedFromLocaleCode,</span>
                        mappedToLocaleCode, mediaType, category);

<span class="fc bfc" id="L172" title="All 2 branches covered.">        for (int i = 0; i &lt; sourcesToTranslate.size(); i++) {</span>
<span class="fc" id="L173">            String source = sourcesToTranslate.get(i);</span>
<span class="fc" id="L174">            AugmentedTranslation translation = translations.get(i);</span>
            // same string may appear several times in a document therefore has several indexes
<span class="fc" id="L176">            Collection&lt;Integer&gt; indexes = untranslatedIndexMap.get(source);</span>
<span class="fc" id="L177">            indexes.forEach(j -&gt; results.set(j, translation.getPlainTranslation()));</span>

            // see if we already have a matched text flow
            // (either in the same document or copied from other document)
<span class="fc" id="L181">            TextFlow tf = indexTextFlowMap.get(indexes.iterator().next());</span>
<span class="fc bfc" id="L182" title="All 2 branches covered.">            if (tf == null) {</span>
<span class="fc" id="L183">                tf = createTextFlow(document, source, fromLocale);</span>
            }
<span class="fc" id="L185">            TextFlowTarget target =</span>
<span class="fc" id="L186">                    new TextFlowTarget(translation.getPlainTranslation(),</span>
<span class="fc" id="L187">                            translation.getRawTranslation(), tf,</span>
                            toLocale, backendID);
<span class="fc" id="L189">            createOrUpdateTextFlowTarget(target);</span>
        }
<span class="fc" id="L191">        return results;</span>
    }

    private @NotNull
    TranslatorBackend getTranslatorBackend(@NotNull BackendID backendID) {
<span class="pc bpc" id="L196" title="1 of 2 branches missed.">        if (translatorBackendMap.containsKey(backendID)) {</span>
<span class="fc" id="L197">            return translatorBackendMap.get(backendID);</span>
        }
<span class="nc" id="L199">        throw new BadRequestException(&quot;Unsupported backendId:&quot; + backendID);</span>
    }

    /**
     * See if the document has the text flow in database already. If not, try to
     * search same content hash from other documents. If any is found, try to
     * copy text flow and text flow target. If none is found, return empty.
     *
     * @param document
     *            current document
     * @param fromLocale
     *            from locale
     * @param toLocale
     *            to locale
     * @param backendID
     *            translation provider
     * @param contentHash
     *            text flow content hash
     * @return optional text flow that has the matching content hash
     */
    private Optional&lt;TextFlow&gt; tryFindTextFlowByContentHashFromDB(
            @NotNull Document document,
            @NotNull Locale fromLocale, @NotNull Locale toLocale,
            @NotNull BackendID backendID, String contentHash) {
<span class="fc" id="L223">        TextFlow matchedHashTf = document.getTextFlows().get(contentHash);</span>
<span class="pc bpc" id="L224" title="1 of 2 branches missed.">        if (matchedHashTf == null) {</span>
            // we don't have text flow for this document yet,
            // now try to search similar text flow from database
<span class="fc" id="L227">            Optional&lt;TextFlow&gt; tfCopy =</span>
<span class="fc" id="L228">                    tryCopyTextFlowAndTargetFromDB(document, fromLocale,</span>
                            toLocale, contentHash, backendID);

<span class="fc" id="L231">            matchedHashTf = tfCopy.orElse(null);</span>
        }
<span class="fc" id="L233">        return Optional.ofNullable(matchedHashTf);</span>
    }

    public int getMaxLength(@NotNull BackendID backendID) {
<span class="nc" id="L237">        return getTranslatorBackend(backendID).getCharLimitPerRequest();</span>
    }


    /**
     * Find matching contentHash and create a new copy of TextFlow and
     * TextFlowTarget if it is not from the same document. Otherwise, return the
     * same copy. If there is not matching contentHash, return empty.
     *
     * TODO: refactor TextFlow to use pos to allow duplication of content
     */
    private Optional&lt;TextFlow&gt; tryCopyTextFlowAndTargetFromDB(Document document,
            Locale fromLocale, Locale toLocale, String contentHash,
            BackendID backendID) {
<span class="fc" id="L251">        Optional&lt;TextFlow&gt; textFlow =</span>
<span class="fc" id="L252">                textFlowDAO.getLatestByContentHash(fromLocale.getLocaleCode(),</span>
                        contentHash);
<span class="fc bfc" id="L254" title="All 2 branches covered.">        if (textFlow.isPresent()) {</span>
<span class="pc bpc" id="L255" title="1 of 2 branches missed.">            if (textFlow.get().getDocument().equals(document)) {</span>
                // this document already has this text flow
<span class="fc" id="L257">                return textFlow;</span>
            } else {
                // found a matching text flow from different document
                // copy textFlow and possible target textFlowTarget
<span class="nc" id="L261">                TextFlow newTfCopy =</span>
<span class="nc" id="L262">                        new TextFlow(document, textFlow.get().getContent(),</span>
                                fromLocale);
<span class="nc" id="L264">                Optional&lt;TextFlowTarget&gt; matchedTft =</span>
<span class="nc" id="L265">                        findTargetByLocaleAndProvider(toLocale, backendID,</span>
<span class="nc" id="L266">                                textFlow.get());</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">                if (matchedTft.isPresent()) {</span>
<span class="nc" id="L268">                    TextFlowTarget tft = matchedTft.get();</span>
<span class="nc" id="L269">                    newTfCopy.getTargets()</span>
<span class="nc" id="L270">                            .add(new TextFlowTarget(tft.getContent(),</span>
<span class="nc" id="L271">                                    tft.getRawContent(), newTfCopy,</span>
                                    toLocale,
                                    backendID));
                }
<span class="nc" id="L275">                newTfCopy = textFlowDAO.persist(newTfCopy);</span>
<span class="nc" id="L276">                document.getTextFlows()</span>
<span class="nc" id="L277">                        .put(newTfCopy.getContentHash(), newTfCopy);</span>
<span class="nc" id="L278">                return Optional.of(newTfCopy);</span>
            }
        }
<span class="fc" id="L281">        return Optional.empty();</span>
    }

    private TextFlow createTextFlow(Document document, String source,
            Locale locale) {
<span class="fc" id="L286">        TextFlow tf = new TextFlow(document, source, locale);</span>
<span class="fc" id="L287">        tf = textFlowDAO.persist(tf);</span>
<span class="fc" id="L288">        return tf;</span>
    }

    /**
     * If found matching TextFlowTarget (locale + backendId),
     * update the content and rawContent, else create new TextFlowTarget
     */
    private void createOrUpdateTextFlowTarget(TextFlowTarget tft) {
<span class="fc" id="L296">        TextFlow tf = tft.getTextFlow();</span>
<span class="fc" id="L297">        Optional&lt;TextFlowTarget&gt; existingTarget = textFlowTargetDAO</span>
<span class="fc" id="L298">                .findTarget(tf, tft.getLocale(), tft.getBackendId());</span>
<span class="pc bpc" id="L299" title="1 of 2 branches missed.">        if (existingTarget.isPresent()) {</span>
<span class="nc" id="L300">            existingTarget.get()</span>
<span class="nc" id="L301">                    .updateContent(tft.getContent(), tft.getRawContent());</span>
        } else {
<span class="fc" id="L303">            textFlowTargetDAO.persist(tft);</span>
        }
<span class="fc" id="L305">    }</span>

    private static Optional&lt;TextFlowTarget&gt; findTargetByLocaleAndProvider(
            Locale toLocale, BackendID backendID, TextFlow textFlow) {
<span class="fc" id="L309">        return textFlow.getTargets().stream()</span>
<span class="pc bpc" id="L310" title="1 of 2 branches missed.">                .filter(target -&gt; target.getLocale().equals(toLocale)</span>
<span class="pc bpc" id="L311" title="1 of 2 branches missed.">                        &amp;&amp; target.getBackendId().equals(backendID))</span>
<span class="fc" id="L312">                .findAny();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>