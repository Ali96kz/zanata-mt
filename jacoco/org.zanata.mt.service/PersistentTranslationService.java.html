<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PersistentTranslationService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mt-server</a> &gt; <a href="index.source.html" class="el_package">org.zanata.mt.service</a> &gt; <span class="el_source">PersistentTranslationService.java</span></div><h1>PersistentTranslationService.java</h1><pre class="source lang-java linenums">package org.zanata.mt.service;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.ejb.TransactionAttribute;
import javax.enterprise.context.ApplicationScoped;
import javax.inject.Inject;
import javax.validation.constraints.NotNull;
import javax.ws.rs.BadRequestException;
import javax.ws.rs.core.MediaType;

import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.Maps;

import com.google.common.collect.Multimap;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.zanata.mt.backend.BackendLocaleCode;
import org.zanata.mt.backend.mock.MockTranslatorBackend;
import org.zanata.mt.dao.TextFlowDAO;
import org.zanata.mt.dao.TextFlowTargetDAO;
import org.zanata.mt.exception.ZanataMTException;
import org.zanata.mt.model.Document;
import org.zanata.mt.model.Locale;
import org.zanata.mt.model.BackendID;
import org.zanata.mt.model.TextFlow;
import org.zanata.mt.model.TextFlowTarget;
import org.zanata.mt.model.AugmentedTranslation;
import org.zanata.mt.backend.ms.MicrosoftTranslatorBackend;
import org.zanata.mt.util.HashUtil;

import com.google.common.collect.Lists;

/**
 * @author Alex Eng &lt;a href=&quot;mailto:aeng@redhat.com&quot;&gt;aeng@redhat.com&lt;/a&gt;
 */
@ApplicationScoped
public class PersistentTranslationService {
<span class="fc" id="L44">    private static final Logger LOG =</span>
<span class="fc" id="L45">        LoggerFactory.getLogger(PersistentTranslationService.class);</span>

    private TextFlowDAO textFlowDAO;

    private TextFlowTargetDAO textFlowTargetDAO;

    private Map&lt;BackendID, TranslatorBackend&gt; translatorBackendMap;

    @SuppressWarnings(&quot;unused&quot;)
<span class="fc" id="L54">    public PersistentTranslationService() {</span>
<span class="fc" id="L55">    }</span>

    @Inject
    public PersistentTranslationService(TextFlowDAO textFlowDAO,
        TextFlowTargetDAO textFlowTargetDAO,
            MicrosoftTranslatorBackend microsoftTranslatorBackend,
<span class="fc" id="L61">            MockTranslatorBackend mockTranslatorBackend) {</span>
<span class="fc" id="L62">        this.textFlowDAO = textFlowDAO;</span>
<span class="fc" id="L63">        this.textFlowTargetDAO = textFlowTargetDAO;</span>

<span class="fc" id="L65">        Map&lt;BackendID, TranslatorBackend&gt; backendMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L66">        backendMap.put(BackendID.MS, microsoftTranslatorBackend);</span>
<span class="fc" id="L67">        backendMap.put(BackendID.DEV, mockTranslatorBackend);</span>

<span class="fc" id="L69">        translatorBackendMap = Collections.unmodifiableMap(backendMap);</span>
<span class="fc" id="L70">    }</span>

    /**
     * Translate multiple string in an api trigger
     *
     * Get from database if exists (hash) from same document,
     * if not exist, get latest TF from DB with matching hash,
     * else from MT engine
     */
    @TransactionAttribute
    public List&lt;String&gt; translate(@NotNull Document document,
            @NotNull List&lt;String&gt; strings,
            @NotNull Locale fromLocale, @NotNull Locale toLocale,
            @NotNull BackendID backendID, @NotNull MediaType mediaType,
            Optional&lt;String&gt; category)
            throws BadRequestException, ZanataMTException {
<span class="pc bpc" id="L86" title="2 of 10 branches missed.">        if (strings == null || strings.isEmpty() || fromLocale == null</span>
                || toLocale == null || backendID == null) {
<span class="fc" id="L88">            throw new BadRequestException();</span>
        }

<span class="fc" id="L91">        List&lt;String&gt; results = new ArrayList&lt;&gt;(strings);</span>
<span class="fc" id="L92">        Multimap&lt;String, Integer&gt; untranslatedIndexMap = ArrayListMultimap.create();</span>

<span class="fc" id="L94">        Map&lt;Integer, TextFlow&gt; indexTextFlowMap = Maps.newHashMap();</span>

        // search from database
<span class="fc bfc" id="L97" title="All 2 branches covered.">        for (int index = 0; index &lt; strings.size(); index++) {</span>
<span class="fc" id="L98">            String string = strings.get(index);</span>
<span class="fc" id="L99">            String contentHash = HashUtil.generateHash(string);</span>
<span class="fc" id="L100">            TextFlow matchedHashTf = document.getTextFlows().get(contentHash);</span>
<span class="pc bpc" id="L101" title="1 of 2 branches missed.">            if (matchedHashTf == null) {</span>
<span class="fc" id="L102">                Optional&lt;TextFlow&gt; tfCopy =</span>
<span class="fc" id="L103">                        copyTextFlowAndTargetFromDB(document, fromLocale,</span>
                                toLocale, contentHash, backendID);

<span class="fc bfc" id="L106" title="All 2 branches covered.">                matchedHashTf = tfCopy.isPresent() ? tfCopy.get() : null;</span>
            }

<span class="fc bfc" id="L109" title="All 2 branches covered.">            if (matchedHashTf != null) {</span>
<span class="fc" id="L110">                Optional&lt;TextFlowTarget&gt; matchedTarget = filterTargetByProvider(</span>
<span class="fc" id="L111">                        matchedHashTf.getTargetsByLocaleCode(</span>
<span class="fc" id="L112">                                toLocale.getLocaleCode()), backendID);</span>

<span class="pc bpc" id="L114" title="1 of 2 branches missed.">                if (matchedTarget.isPresent()) {</span>
<span class="fc" id="L115">                    TextFlowTarget matchedEntity = matchedTarget.get();</span>
<span class="fc" id="L116">                    LOG.info(</span>
                            &quot;Found match, Source {}:{}:{}\nTranslation {}:{}&quot;,
<span class="fc" id="L118">                            fromLocale.getLocaleCode(), document.getUrl(),</span>
                            string,
<span class="fc" id="L120">                            toLocale.getLocaleCode(),</span>
<span class="fc" id="L121">                            matchedEntity.getContent());</span>

<span class="fc" id="L123">                    results.set(index, matchedEntity.getContent());</span>
<span class="fc" id="L124">                } else {</span>
<span class="nc" id="L125">                    untranslatedIndexMap.put(string, index);</span>
<span class="nc" id="L126">                    indexTextFlowMap.put(index, matchedHashTf);</span>
                }
<span class="fc" id="L128">            } else {</span>
<span class="fc" id="L129">                untranslatedIndexMap.put(string, index);</span>
<span class="fc" id="L130">                indexTextFlowMap.put(index, null);</span>
            }
        }

        // all translations got from database records
<span class="fc bfc" id="L135" title="All 2 branches covered.">        if (untranslatedIndexMap.isEmpty()) {</span>
<span class="fc" id="L136">            return results;</span>
        }

        // trigger MT engine search
<span class="fc" id="L140">        TranslatorBackend translatorBackend = getTranslatorBackend(backendID);</span>

<span class="fc" id="L142">        List&lt;String&gt; sources = Lists.newArrayList(untranslatedIndexMap.keySet());</span>

<span class="fc" id="L144">        BackendLocaleCode mappedFromLocaleCode =</span>
<span class="fc" id="L145">                translatorBackend.getMappedLocale(fromLocale.getLocaleCode());</span>
<span class="fc" id="L146">        BackendLocaleCode mappedToLocaleCode =</span>
<span class="fc" id="L147">                translatorBackend.getMappedLocale(toLocale.getLocaleCode());</span>

<span class="fc" id="L149">        List&lt;AugmentedTranslation&gt; translations =</span>
<span class="fc" id="L150">                translatorBackend.translate(sources, mappedFromLocaleCode,</span>
                        mappedToLocaleCode, mediaType, category);

<span class="fc bfc" id="L153" title="All 2 branches covered.">        for (String source: sources) {</span>
<span class="fc" id="L154">            Collection&lt;Integer&gt; indexes = untranslatedIndexMap.get(source);</span>
<span class="fc" id="L155">            AugmentedTranslation translation = translations.get(sources.indexOf(source));</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">            for (int index: indexes) {</span>
<span class="fc" id="L157">                results.set(index, translation.getPlainTranslation());</span>
<span class="fc" id="L158">            }</span>

<span class="fc" id="L160">            TextFlow tf = indexTextFlowMap.get(indexes.iterator().next());</span>
<span class="pc bpc" id="L161" title="1 of 2 branches missed.">            if (tf == null) {</span>
<span class="fc" id="L162">                tf = createTextFlow(document, source, fromLocale);</span>
            }
<span class="fc" id="L164">            TextFlowTarget target =</span>
<span class="fc" id="L165">                    new TextFlowTarget(translation.getPlainTranslation(),</span>
<span class="fc" id="L166">                            translation.getRawTranslation(), tf,</span>
                            toLocale, backendID);
<span class="fc" id="L168">            createOrUpdateTextFlowTarget(target);</span>
<span class="fc" id="L169">        }</span>
<span class="fc" id="L170">        return results;</span>
    }

    private @NotNull
    TranslatorBackend getTranslatorBackend(@NotNull BackendID backendID) {
<span class="pc bpc" id="L175" title="1 of 2 branches missed.">        if (translatorBackendMap.containsKey(backendID)) {</span>
<span class="fc" id="L176">            return translatorBackendMap.get(backendID);</span>
        }
<span class="nc" id="L178">        throw new BadRequestException(&quot;Unsupported backendId:&quot; + backendID);</span>
    }

    /**
     * Find matching contentHash and create a new copy of TextFlow and
     * TextFlowTarget if it is not from the same document. Otherwise, return the
     * same copy.
     *
     * TODO: refactor TextFlow to use pos to allow duplication of content
     */
    private Optional&lt;TextFlow&gt; copyTextFlowAndTargetFromDB(Document document,
            Locale fromLocale, Locale toLocale, String contentHash,
            BackendID backendID) {
<span class="fc" id="L191">        Optional&lt;TextFlow&gt; textFlow =</span>
<span class="fc" id="L192">                textFlowDAO.getLatestByContentHash(fromLocale.getLocaleCode(),</span>
                        contentHash);
<span class="fc" id="L194">        Optional&lt;TextFlow&gt; copy = Optional.empty();</span>
<span class="fc bfc" id="L195" title="All 2 branches covered.">        if (textFlow.isPresent()) {</span>
<span class="pc bpc" id="L196" title="1 of 2 branches missed.">            if (textFlow.get().getDocument().equals(document)) {</span>
<span class="fc" id="L197">                copy = textFlow;</span>
            } else {
                // copy textFlow and target textFlowTarget
<span class="nc" id="L200">                List&lt;TextFlowTarget&gt; tfts =</span>
<span class="nc" id="L201">                        textFlow.get().getTargetsByLocaleCode(toLocale.getLocaleCode());</span>
<span class="nc" id="L202">                TextFlow newTfCopy =</span>
<span class="nc" id="L203">                        new TextFlow(document, textFlow.get().getContent(),</span>
                                fromLocale);
<span class="nc bnc" id="L205" title="All 2 branches missed.">                if (!tfts.isEmpty()) {</span>
<span class="nc" id="L206">                    Optional&lt;TextFlowTarget&gt; tft =</span>
<span class="nc" id="L207">                            filterTargetByProvider(tfts, backendID);</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">                    if (tft.isPresent()) {</span>
<span class="nc" id="L209">                        newTfCopy.getTargets()</span>
<span class="nc" id="L210">                                .add(new TextFlowTarget(tft.get().getContent(),</span>
<span class="nc" id="L211">                                        tft.get().getRawContent(), newTfCopy,</span>
                                        toLocale,
<span class="nc" id="L213">                                        tft.get().getBackendId()));</span>
                    }
                }
<span class="nc" id="L216">                newTfCopy = textFlowDAO.persist(newTfCopy);</span>
<span class="nc" id="L217">                document.getTextFlows()</span>
<span class="nc" id="L218">                        .put(newTfCopy.getContentHash(), newTfCopy);</span>
<span class="nc" id="L219">                return Optional.of(newTfCopy);</span>
            }
        }
<span class="fc" id="L222">        return copy;</span>
    }

    private TextFlow createTextFlow(Document document, String source,
            Locale locale) {
<span class="fc" id="L227">        TextFlow tf = new TextFlow(document, source, locale);</span>
<span class="fc" id="L228">        tf = textFlowDAO.persist(tf);</span>
<span class="fc" id="L229">        return tf;</span>
    }

    /**
     * If found matching TextFlowTarget (locale + backendId),
     * update the content and rawContent, else create new TextFlowTarget
     */
    private void createOrUpdateTextFlowTarget(TextFlowTarget tft) {
<span class="fc" id="L237">        TextFlow tf = tft.getTextFlow();</span>
<span class="fc" id="L238">        List&lt;TextFlowTarget&gt; existingTfts =</span>
<span class="fc" id="L239">                tf.getTargetsByLocaleCode(tft.getLocale().getLocaleCode());</span>
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">        if (existingTfts.isEmpty()) {</span>
<span class="fc" id="L241">            textFlowTargetDAO.persist(tft);</span>
<span class="fc" id="L242">            tf.getTargets().add(tft);</span>
        } else {
<span class="nc" id="L244">            Optional&lt;TextFlowTarget&gt; existingTft =</span>
<span class="nc" id="L245">                    filterTargetByProvider(existingTfts, tft.getBackendId());</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">            if (existingTft.isPresent()) {</span>
<span class="nc" id="L247">                existingTft.get()</span>
<span class="nc" id="L248">                        .updateContent(tft.getContent(), tft.getRawContent());</span>
<span class="nc" id="L249">                textFlowTargetDAO.persist(existingTft.get());</span>
            }
        }
<span class="fc" id="L252">    }</span>

    private Optional&lt;TextFlowTarget&gt; filterTargetByProvider(
            List&lt;TextFlowTarget&gt; targets, BackendID backendID) {
<span class="pc bpc" id="L256" title="1 of 2 branches missed.">        for (TextFlowTarget target : targets) {</span>
<span class="pc bpc" id="L257" title="1 of 2 branches missed.">            if (target.getBackendId().equals(backendID)) {</span>
<span class="fc" id="L258">                return Optional.of(target);</span>
            }
<span class="nc" id="L260">        }</span>
<span class="nc" id="L261">        return Optional.empty();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>